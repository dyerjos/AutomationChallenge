# Automation Recruiting Challenge
In this challenge, you will write a program-generator for a primitive (and fictional) laser cutter machine.
Given a desired output pattern, your solution should generate a program to be executed by the laser cutter
that would remove material from blank stock of the same size in a manner that produces the output pattern.
The generated programs must also be reasonably efficient. (See below for more detail.)

You may solve the problem using any language of your choice. You are welcome to make use of any
publicly-available dependencies installable through standard package managers like pip, npm, or cargo,
though such dependencies are likely unnecessary.

Submission instructions are included below. If you have any questions, please email them to David at david@formlogic.com.

## Challenge Details

The laser cutter operates on a discrete two-dimensional grid.
We will refer to each position in the grid by an (X, Y) coordinate, where X corresponds to the columns
(starting at 0 on the far left, and increasing by one with each step to the right), and Y corresponds to rows
(starting at 0 on the top, and increasing by one with each step down).

Programs for the laser cutter are comprised of a sequence of the following two kinds of commands:

1. The `M01` command, which toggles whether the laser is on.
2. The `G01` command, which tells the laser to move to a specified location. When using the `G01` command,
`X` (column) and `Y` (row) coordinates must also be specified as the destination for the laser head.

You may always assume that at the start of the program, the laser is off, and the laser head is at position (0, 0).

Here is a simple example of a program that can be run by this machine:
```
G01 X2.00 Y1.00
M01
G01 X6.00 Y1.00
M01
G01 X2.00 Y3.00
M01
G01 X6.00 Y3.00
M01
G01 X0.00 Y0.00
```
Running this program causes the machine to perform the following actions:

1. Move the laser head to the coordinate (2.00, 1.00)
2. Turn on the laser
3. With the laser on, move the laser head to (6.00, 1.00)
4. Turn off the laser
5. With the laser off, move the laser head to (2.00, 3.00)
6. Turn on the laser
7. With the laser on, move the laser head to (6.00, 3.00)
8. Turn off the laser
9. Return the laser head to (0.00, 0.00)

If we imagine starting with the following "blank" grid:

```
.........
.........
.........
.........
.........
```

then we can visualize the result of this program as:

```
.........
..XXXXX..
.........
..XXXXX..
.........
```

where `.` represents an untouched grid square, and `X` represents a grid square that was "cut" by the laser. 

During the operation of the laser, a given square should be considered "cut" by the laser
provided that, while the laser is on, the laser head passes through a point at a
**euclidean distance of <= 0.5 from the center of the respective square**.
So, for example, running the following program

```
M01
G01 X4.0 Y3.0
M01
G01 X0.0 Y0.0
```

on a 4x5 grid would generate the following result:

```
X....
.XX..
..XX.
....X
```

The goal of this challenge is to write a program that takes as input a string like the visualized "result" shown above,
and generates as output a laser cutter program that would produce that result. In addition, any program you generate
should finish by turning off the laser and returning the laser head to (0.0, 0.0).

## Duration

The laser head can move at a rate of 1 unit per second.

So, for example, traveling straight from (0.0, 0.0) to (3.0, 0.0) takes 3.0 seconds;
traveling straight from (0.0, 0.0) to (3.0, 4.0) takes 5.0 seconds.

In addition, turning the laser on or off takes 1 second, during which the laser will not move.

Thus, the example program above:
```
G01 X2.00 Y1.00
M01
G01 X6.00 Y1.00
M01
G01 X2.00 Y3.00
M01
G01 X6.00 Y3.00
M01
G01 X0.00 Y0.00
```
should take about 25.4 seconds to run.

A trivial solution to this challenge would be to visit all squares in the grid, and toggle the laser on
depending on whether the square should be cut or not. However, the execution duration for this solution
would be unreasonably long for patterns that only require cutting a small fraction of the grid.

Your solution should produce programs that run substantially faster than this "brute force" baseline.
In the test cases below, we provide both a maximum allowed duration, and the duration of the program
generated by our own solution to the challenge.

We are less concerned with the runtime and computational complexity of the generation process itself,
but your solution should be efficient enough that it can quickly generate solutions for reasonably large grids 
(e.g., 200x200 or larger).

## Test cases

The test cases shown below are all fairly small, but as noted above, your generator should be able to readily handle
larger grids as well. 

#### Case 1
Desired output pattern:
```
..XXX..
XX...XX
..XXX..
```
Program generated by our solution:
```
G01 X0.00 Y1.00
M01
G01 X1.00 Y1.00
G01 X2.00 Y2.00
G01 X4.00 Y2.00
G01 X5.00 Y1.00
G01 X6.00 Y1.00
M01
G01 X2.00 Y0.00
M01
G01 X4.00 Y0.00
M01
G01 X0.00 Y0.00
```

* Our solution's duration: 21.952 seconds
* Maximum allowed duration: 35.8 seconds

#### Case 2
Desired output pattern:
```
....X....
..XXXXX..
.........
..XXXXX..
....X....
```
Program generated by our solution:
```
G01 X2.00 Y1.00
M01
G01 X6.00 Y1.00
M01
G01 X2.00 Y3.00
M01
G01 X4.00 Y3.00
G01 X4.00 Y4.00
G01 X5.00 Y3.00
G01 X6.00 Y3.00
M01
G01 X4.00 Y0.00
M01
M01
G01 X0.00 Y0.00
```
* Our solution's duration: 29.728 seconds
* Maximum allowed duration: 58.8 seconds

#### Case 3
Desired output pattern:
```
......XXX
........X
X...X...X
X........
XXX......
```
Program generated by our solution:
```
G01 X0.00 Y2.00
M01
G01 X0.00 Y4.00
G01 X2.00 Y4.00
M01
G01 X4.00 Y2.00
M01
M01
G01 X6.00 Y0.00
M01
G01 X8.00 Y0.00
G01 X8.00 Y2.00
M01
G01 X0.00 Y0.00
```
* Our duration: 29.903 seconds
* Maximum allowed duration: 57.3 seconds

## Submission

Your solution can be submitted through the following steps:

* Upload the project as a private repository on GitHub
* Add David Montague (GitHub user dmontagu) to the repository
* Email David at david@formlogic.com once your submission is ready

We do not require you to implement any particular API for applying your program generator to new
desired output patterns, but it should be easy for us to run your generator on new test cases.
Please describe how to do this in your submission's README.md.

Please also include with your submission any auxiliary code you use to verify the correctness of your solution.
